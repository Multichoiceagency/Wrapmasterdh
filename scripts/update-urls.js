/**
 * Update all local URLs to Supabase Storage URLs in the codebase
 *
 * Usage: node scripts/update-urls.js
 *
 * This script reads the url-mapping.json file generated by upload-to-supabase.js
 * and updates all references in the codebase.
 */

const fs = require('fs');
const path = require('path');
const { promisify } = require('util');

const readdir = promisify(fs.readdir);
const stat = promisify(fs.stat);
const readFile = promisify(fs.readFile);
const writeFile = promisify(fs.writeFile);

// Configuration
const PROJECT_DIR = path.join(__dirname, '..');
const MAPPING_FILE = path.join(PROJECT_DIR, 'url-mapping.json');

// Files/folders to scan
const SCAN_EXTENSIONS = ['.tsx', '.ts', '.jsx', '.js', '.json', '.css', '.scss'];
const SKIP_FOLDERS = ['node_modules', '.git', '.next', 'public', 'scripts'];

// Load URL mapping
if (!fs.existsSync(MAPPING_FILE)) {
  console.error('URL mapping file not found. Run upload-to-supabase.js first.');
  process.exit(1);
}

const urlMapping = JSON.parse(fs.readFileSync(MAPPING_FILE, 'utf8'));
console.log(`Loaded ${Object.keys(urlMapping).length} URL mappings\n`);

// Get all source files recursively
async function getAllSourceFiles(dir) {
  const files = [];
  const items = await readdir(dir);

  for (const item of items) {
    const fullPath = path.join(dir, item);
    const relativePath = path.relative(PROJECT_DIR, fullPath);

    // Skip certain folders
    if (SKIP_FOLDERS.some(skip => relativePath.startsWith(skip))) {
      continue;
    }

    const stats = await stat(fullPath);

    if (stats.isDirectory()) {
      const subFiles = await getAllSourceFiles(fullPath);
      files.push(...subFiles);
    } else {
      const ext = path.extname(item).toLowerCase();
      if (SCAN_EXTENSIONS.includes(ext)) {
        files.push(fullPath);
      }
    }
  }

  return files;
}

// Update URLs in a file
async function updateFile(filePath) {
  let content = await readFile(filePath, 'utf8');
  let originalContent = content;
  let replacements = 0;

  // Sort mappings by length (longest first) to avoid partial replacements
  const sortedPaths = Object.keys(urlMapping).sort((a, b) => b.length - a.length);

  for (const oldPath of sortedPaths) {
    const newUrl = urlMapping[oldPath];

    // Various patterns to match
    const patterns = [
      // Direct path references: "/images/foo.jpg"
      new RegExp(`"${escapeRegex(oldPath)}"`, 'g'),
      new RegExp(`'${escapeRegex(oldPath)}'`, 'g'),
      new RegExp(`\`${escapeRegex(oldPath)}\``, 'g'),

      // src= and href= attributes
      new RegExp(`src=["']${escapeRegex(oldPath)}["']`, 'g'),
      new RegExp(`href=["']${escapeRegex(oldPath)}["']`, 'g'),

      // Template literals with path
      new RegExp(`\\$\\{["'\`]?${escapeRegex(oldPath)}["'\`]?\\}`, 'g'),
    ];

    for (const pattern of patterns) {
      const matches = content.match(pattern);
      if (matches) {
        content = content.replace(pattern, (match) => {
          replacements++;
          // Preserve quotes/syntax
          if (match.startsWith('src=')) return `src="${newUrl}"`;
          if (match.startsWith('href=')) return `href="${newUrl}"`;
          if (match.startsWith('"')) return `"${newUrl}"`;
          if (match.startsWith("'")) return `'${newUrl}'`;
          if (match.startsWith('`')) return `\`${newUrl}\``;
          return newUrl;
        });
      }
    }
  }

  // Only write if changes were made
  if (content !== originalContent) {
    await writeFile(filePath, content, 'utf8');
    return replacements;
  }

  return 0;
}

// Escape special regex characters
function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

// Main function
async function main() {
  console.log('='.repeat(60));
  console.log('Update URLs in Codebase');
  console.log('='.repeat(60));
  console.log(`\nProject: ${PROJECT_DIR}\n`);

  // Get all source files
  console.log('Scanning source files...');
  const files = await getAllSourceFiles(PROJECT_DIR);
  console.log(`Found ${files.length} source files\n`);

  // Update each file
  let totalReplacements = 0;
  let filesModified = 0;

  for (const file of files) {
    const relativePath = path.relative(PROJECT_DIR, file);
    const replacements = await updateFile(file);

    if (replacements > 0) {
      console.log(`Updated ${relativePath}: ${replacements} replacement(s)`);
      totalReplacements += replacements;
      filesModified++;
    }
  }

  console.log('\n' + '='.repeat(60));
  console.log('Update Complete!');
  console.log('='.repeat(60));
  console.log(`Files modified: ${filesModified}`);
  console.log(`Total replacements: ${totalReplacements}`);
}

main().catch(console.error);
